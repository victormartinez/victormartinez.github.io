{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2020/2020-10-02-Configure_o_Alembic_e_o_SQLAlchemy_para_um_schema_diferente/","result":{"data":{"site":{"siteMetadata":{"title":null,"siteUrl":"https://vcrmartinez.com","social":{"twitter":"vcrmartinez","github":"victormartinez","linkedin":"vcrmartinez","speakerdeck":"victormartinez"}}},"markdownRemark":{"id":"77e5ad42-7f3a-5651-a9bc-d3f14ef5e342","excerpt":"Há algum tempo, desenvolvi um projeto de back-end que usava uma instância compartilhada do Postgres. Se você usar o Flask, como eu fiz, provavelmente sua camada…","html":"<p>Há algum tempo, desenvolvi um projeto de back-end que usava uma instância compartilhada do Postgres. Se você usar o Flask, como eu fiz, provavelmente sua camada de migração é tratada pelo Alembic e o ORM de escolha sendo o SQLAlchemy. Devido a restrições da arquitetura, o projeto usou um esquema diferente (<em>public</em> não estava disponível). <strong>Após a primeira migração, qualquer alteração no modelo não foi identificada pelo Alembic e todas as tabelas foram geradas novamente.</strong></p>\n<h2>O Cenário</h2>\n<p>Para lidar com um novo schema de banco de dados, especifiquei os argumentos nos models, conforme ilustrado pelo exemplo abaixo.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>Model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    __tablename__ <span class=\"token operator\">=</span> <span class=\"token string\">\"project_users\"</span>\n    __table_args__ <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"schema\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"users\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token builtin\">id</span> <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span>Column<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>Integer<span class=\"token punctuation\">,</span> primary_key<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    email <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span>Column<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>String<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> unique<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>No entanto, isso é apenas uma coisa que deve ser feita. A outra é <strong>configurar corretamente o Alembic apontar para o novo esquema.</strong></p>\n<h2>A solução</h2>\n<p>Não estava claro para mim o que estava acontecendo mas <a href=\"https://stackoverflow.com/questions/26275041/alembic-sqlalchemy-does-not-detect-existing-tables\">esta thread</a> no StackOverflow tornou claro. Em resumo:</p>\n<p>(1) É necessário permitir ao Alembic escanear todos os schemas do banco de dados. Isso é feito através da configuração <code class=\"language-text\">EnvironmentContext.configure.include_schemas</code>. Assim, o dialeto de banco de dados (Postgres neste cenário) executa a query abaixo para obter todos os schemas:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> nspname <span class=\"token keyword\">FROM</span> pg_namespace <span class=\"token keyword\">WHERE</span> nspname <span class=\"token operator\">NOT</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'pg_%'</span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> nspname</code></pre></div>\n<p>(2) A query acima retorna os schemas mas nós estamos interessados apenas naquele que nossa aplicação usa. Ao configurar <code class=\"language-text\">EnvironmentContext.configure.include_object</code>, nós podemos especificar um <em>callable</em> responsável por filtrar quais objetos do banco de dados devem ser considerados.</p>\n<h2>Trecho de código</h2>\n<p>Após executar o comando de init, <code class=\"language-text\">migrations/env.py</code> é gerado. Uma vez que ele especifica o objeto de configuração, nós vamos precisar modificá-lo um pouco. O trecho de código abaixo ilustra isso.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># ...</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">include_object</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> type_<span class=\"token punctuation\">,</span> reflected<span class=\"token punctuation\">,</span> compare_to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">hasattr</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"schema\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">object</span><span class=\"token punctuation\">.</span>schema <span class=\"token operator\">==</span> target_metadata<span class=\"token punctuation\">.</span>schema\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">object</span><span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">.</span>schema <span class=\"token operator\">==</span> target_metadata<span class=\"token punctuation\">.</span>schema\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">run_migrations_offline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"</span>\n    url <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>get_main_option<span class=\"token punctuation\">(</span><span class=\"token string\">\"sqlalchemy.url\"</span><span class=\"token punctuation\">)</span>\n    context<span class=\"token punctuation\">.</span>configure<span class=\"token punctuation\">(</span>\n        url<span class=\"token operator\">=</span>url<span class=\"token punctuation\">,</span> target_metadata<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">,</span> literal_binds<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n        version_table_schema<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">.</span>schema<span class=\"token punctuation\">,</span>\n        include_schemas<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n        include_object<span class=\"token operator\">=</span>include_object<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> context<span class=\"token punctuation\">.</span>begin_transaction<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        context<span class=\"token punctuation\">.</span>run_migrations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">run_migrations_online</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"</span>\n\n    <span class=\"token comment\"># this callback is used to prevent an auto-migration from being generated</span>\n    <span class=\"token comment\"># when there are no changes to the schema</span>\n    <span class=\"token comment\"># reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">process_revision_directives</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> revision<span class=\"token punctuation\">,</span> directives<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>cmd_opts<span class=\"token punctuation\">,</span> <span class=\"token string\">'autogenerate'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            script <span class=\"token operator\">=</span> directives<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> script<span class=\"token punctuation\">.</span>upgrade_ops<span class=\"token punctuation\">.</span>is_empty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                directives<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n                logger<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">(</span><span class=\"token string\">'No changes in schema detected.'</span><span class=\"token punctuation\">)</span>\n\n    connectable <span class=\"token operator\">=</span> engine_from_config<span class=\"token punctuation\">(</span>\n        config<span class=\"token punctuation\">.</span>get_section<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>config_ini_section<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        prefix<span class=\"token operator\">=</span><span class=\"token string\">'sqlalchemy.'</span><span class=\"token punctuation\">,</span>\n        poolclass<span class=\"token operator\">=</span>pool<span class=\"token punctuation\">.</span>NullPool<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> connectable<span class=\"token punctuation\">.</span>connect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n        context<span class=\"token punctuation\">.</span>configure<span class=\"token punctuation\">(</span>\n            connection<span class=\"token operator\">=</span>connection<span class=\"token punctuation\">,</span>\n            target_metadata<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">,</span>\n            version_table_schema<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">.</span>schema<span class=\"token punctuation\">,</span>\n            include_schemas<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n            process_revision_directives<span class=\"token operator\">=</span>process_revision_directives<span class=\"token punctuation\">,</span>\n            include_object<span class=\"token operator\">=</span>include_object<span class=\"token punctuation\">,</span>\n            <span class=\"token operator\">**</span>current_app<span class=\"token punctuation\">.</span>extensions<span class=\"token punctuation\">[</span><span class=\"token string\">'migrate'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>configure_args\n        <span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">with</span> context<span class=\"token punctuation\">.</span>begin_transaction<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            context<span class=\"token punctuation\">.</span>run_migrations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># ...</span></code></pre></div>\n<ul>\n<li><strong>Linhas 21 e 55</strong> configuram <code class=\"language-text\">include_schema=True</code>.</li>\n<li><strong>Linhas 22 e 57</strong> passam o <em>callable</em> <code class=\"language-text\">include_object</code> que corresponde a função da 4ª linha.</li>\n<li><strong>Linha 3</strong> corresponde ao nosso <em>callable</em> que especifica se o Alembic deve considerar ou não o objeto em questão. Preste atenção que na 5ª linha nós verificamos se o objeto tem um atributo <code class=\"language-text\">schema</code>. Finalmente, as linhas 6 e 7 comparam o schema com aquele configurado nos models do SQLAlchemy.</li>\n</ul>","frontmatter":{"title":"Configure o Alembic e o SQLAlchemy para um schema diferente","date":"2020-10-02T00:00:00","description":null,"tags":["alembic","sqlalchemy","migration","schema","public","python","flask"],"image_url":"https://unsplash.com/photos/lRoX0shwjUQ","image_author":"Jan Antonin Kolar","image":{"publicURL":"/static/907c362e5b0dde72197319e2447ee8b0/featured.jpg"}},"fields":{"slug":"/2020/2020-10-02-Configure_o_Alembic_e_o_SQLAlchemy_para_um_schema_diferente/"},"timeToRead":3}},"pageContext":{"id":"77e5ad42-7f3a-5651-a9bc-d3f14ef5e342","language":"pt","intl":{"language":"pt","languages":["pt"],"messages":{"of":"de","or":"ou","Next":"Próximo","Previous":"Anterior","reading":"leitura","Comments":"Comentários","Featured_image_credits":"Créditos da imagem de destaque","Not_Found":"Não Encontrado","Not_Found_Text":"A página que você está procurando pode ter sido removida, ter seu nome alterado ou estar temporariamente indisponível.","Not_Found_Nav":"Você pode ir para","Warning_deprecated":"Atenção: esse post foi escrito a algum tempo e pode não ser mais válido, ok?"},"routed":false,"originalPath":"/blog/2020/2020-10-02-Configure_o_Alembic_e_o_SQLAlchemy_para_um_schema_diferente/","redirect":true,"defaultLanguage":"pt"}}},"staticQueryHashes":["4061151221"]}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2020/2020-10-02-Pointing_alembic_and_sqlalchemy_to_a_different_schema/","result":{"data":{"site":{"siteMetadata":{"title":null,"siteUrl":"https://vcrmartinez.com","social":{"twitter":"vcrmartinez","github":"victormartinez","linkedin":"vcrmartinez","speakerdeck":"victormartinez"}}},"markdownRemark":{"id":"1750e46a-1de8-5dad-92ae-4282b7df1592","excerpt":"A while ago I developed a backend project that used a shared instance of Postgres. If you use Flask, as I did, probably your migration layer is dealt by Alembicâ€¦","html":"<p>A while ago I developed a backend project that used a shared instance of Postgres. If you use Flask, as I did, probably your migration layer is dealt by Alembic and the ORM of choice is SQLAlchemy. Due to architectural constraints, the project used a different schema (<em>public</em> was not available). <strong>After the first migration, any change in the model was not identified by Alembic and all tables were generated again.</strong></p>\n<h2>The scenario</h2>\n<p>In order to address a new database schema I specified table arguments in the models as illustrated by the example below.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>Model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    __tablename__ <span class=\"token operator\">=</span> <span class=\"token string\">\"project_users\"</span>\n    __table_args__ <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"schema\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"users\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token builtin\">id</span> <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span>Column<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>Integer<span class=\"token punctuation\">,</span> primary_key<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    email <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span>Column<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>String<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> unique<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>However, that is just one thing that must be done. The other is to <strong>properly configure Alembic to watch the new schema.</strong></p>\n<h2>The solution</h2>\n<p>It was unclear to me what was happening but <a href=\"https://stackoverflow.com/questions/26275041/alembic-sqlalchemy-does-not-detect-existing-tables\">this issue</a> in StackOverflow clarified. To sum up:</p>\n<p>(1) It is necessary to allow Alembic to scan all schemas in database. It is done by setting <code class=\"language-text\">EnvironmentContext.configure.include_schemas</code> in the configuration context. Thus, the database dialect (Postgres in this scenario) executes the query below to retrieve the schemas:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> nspname <span class=\"token keyword\">FROM</span> pg_namespace <span class=\"token keyword\">WHERE</span> nspname <span class=\"token operator\">NOT</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'pg_%'</span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> nspname</code></pre></div>\n<p>(2) The query above brings the schemas but we are interested in the one our application uses. By setting <code class=\"language-text\">EnvironmentContext.configure.include_object</code>, we can specify a callable responsible for filtering which database objects should be considered.</p>\n<h2>Code Snippet</h2>\n<p>After running the init command, <code class=\"language-text\">migrations/env.py</code> is generated. Since it specifies the configuration object, we will need to modify it a little bit. The code bellow illustrates that.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># ...</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">include_object</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> type_<span class=\"token punctuation\">,</span> reflected<span class=\"token punctuation\">,</span> compare_to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">hasattr</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"schema\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">object</span><span class=\"token punctuation\">.</span>schema <span class=\"token operator\">==</span> target_metadata<span class=\"token punctuation\">.</span>schema\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">object</span><span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">.</span>schema <span class=\"token operator\">==</span> target_metadata<span class=\"token punctuation\">.</span>schema\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">run_migrations_offline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"</span>\n    url <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>get_main_option<span class=\"token punctuation\">(</span><span class=\"token string\">\"sqlalchemy.url\"</span><span class=\"token punctuation\">)</span>\n    context<span class=\"token punctuation\">.</span>configure<span class=\"token punctuation\">(</span>\n        url<span class=\"token operator\">=</span>url<span class=\"token punctuation\">,</span> target_metadata<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">,</span> literal_binds<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n        version_table_schema<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">.</span>schema<span class=\"token punctuation\">,</span>\n        include_schemas<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n        include_object<span class=\"token operator\">=</span>include_object<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> context<span class=\"token punctuation\">.</span>begin_transaction<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        context<span class=\"token punctuation\">.</span>run_migrations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">run_migrations_online</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"</span>\n\n    <span class=\"token comment\"># this callback is used to prevent an auto-migration from being generated</span>\n    <span class=\"token comment\"># when there are no changes to the schema</span>\n    <span class=\"token comment\"># reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">process_revision_directives</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> revision<span class=\"token punctuation\">,</span> directives<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>cmd_opts<span class=\"token punctuation\">,</span> <span class=\"token string\">'autogenerate'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            script <span class=\"token operator\">=</span> directives<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> script<span class=\"token punctuation\">.</span>upgrade_ops<span class=\"token punctuation\">.</span>is_empty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                directives<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n                logger<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">(</span><span class=\"token string\">'No changes in schema detected.'</span><span class=\"token punctuation\">)</span>\n\n    connectable <span class=\"token operator\">=</span> engine_from_config<span class=\"token punctuation\">(</span>\n        config<span class=\"token punctuation\">.</span>get_section<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>config_ini_section<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        prefix<span class=\"token operator\">=</span><span class=\"token string\">'sqlalchemy.'</span><span class=\"token punctuation\">,</span>\n        poolclass<span class=\"token operator\">=</span>pool<span class=\"token punctuation\">.</span>NullPool<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> connectable<span class=\"token punctuation\">.</span>connect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n        context<span class=\"token punctuation\">.</span>configure<span class=\"token punctuation\">(</span>\n            connection<span class=\"token operator\">=</span>connection<span class=\"token punctuation\">,</span>\n            target_metadata<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">,</span>\n            version_table_schema<span class=\"token operator\">=</span>target_metadata<span class=\"token punctuation\">.</span>schema<span class=\"token punctuation\">,</span>\n            include_schemas<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n            process_revision_directives<span class=\"token operator\">=</span>process_revision_directives<span class=\"token punctuation\">,</span>\n            include_object<span class=\"token operator\">=</span>include_object<span class=\"token punctuation\">,</span>\n            <span class=\"token operator\">**</span>current_app<span class=\"token punctuation\">.</span>extensions<span class=\"token punctuation\">[</span><span class=\"token string\">'migrate'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>configure_args\n        <span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">with</span> context<span class=\"token punctuation\">.</span>begin_transaction<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            context<span class=\"token punctuation\">.</span>run_migrations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># ...</span></code></pre></div>\n<ul>\n<li><strong>Lines 21 and 55</strong> set <code class=\"language-text\">include_schema=True</code>.</li>\n<li><strong>Lines 22 and 57</strong> pass a callable <code class=\"language-text\">include_object</code> that corresponds to the function at 4th line.</li>\n<li><strong>Line 3</strong> is our callable that specifies whether Alembic should consider or not the object in question. Pay attention that in the 5th line we check whether the object has a schema attribute. Finally lines 6 and 7 compare the schema wih the one configured in the SQLAlchemy models.</li>\n</ul>","frontmatter":{"title":"Point Alembic and SQLAlchemy to a different schema","date":"Oct 02, 2020","description":null,"tags":["alembic","sqlalchemy","migration","schema","public","python","flask"],"rating":null,"image_url":"https://unsplash.com/photos/lRoX0shwjUQ","image_author":"Jan Antonin Kolar"},"fields":{"slug":"/2020/2020-10-02-Pointing_alembic_and_sqlalchemy_to_a_different_schema/"},"timeToRead":3},"previous":null,"next":{"fields":{"slug":"/2020/2020-05-26-Review_Monolith_to_Microservices/"},"frontmatter":{"title":"Review: Monolith to Microservices"}}},"pageContext":{"id":"1750e46a-1de8-5dad-92ae-4282b7df1592","previousPostId":"378480db-f601-50dd-9885-79ddcbe2e6a2","nextPostId":"9a321162-e375-59b5-9632-1a43c967c073","language":"en","intl":{"language":"en","languages":["en","pt"],"messages":{"of":"of","Next":"Next","Previous":"Previous","reading":"reading","Comments":"Comments","Featured_image_credits":"Featured image credits"},"routed":false,"originalPath":"/blog/2020/2020-10-02-Pointing_alembic_and_sqlalchemy_to_a_different_schema/","redirect":true,"defaultLanguage":"en"}}},"staticQueryHashes":["2841359383"]}